# 重定向

- I/O是输入/输出（input/output）的缩写。
- I/O 重定向可以把`命令行的输入`重定向**为从文件获取内容**，也可以把`命令行的输出结果`重定向**到文件中**。

| 命令 | 功能                                                   |
| ---- | ------------------------------------------------------ |
| cat  | 合并文件                                               |
| sort | 对文件排序                                             |
| uniq | 报告或删除文件中的重复行                               |
| wc   | 打印文件中的换行符、字、字节个数                       |
| grep | 打印匹配行                                             |
| head | 输出文件的第一部分内容                                 |
| tail | 输出文件的最后一部分内容                               |
| tee  | 读取标准输入的数据，并将其内容输出到标准输出和文件中。 |

## 标准输入、标准输出、标准错误

- I/O重定向可以改变输出内容发送的目的地，也可以改变输入内容的来源地。通常来说，输出内容显示在屏幕上，输入内容来自于键盘，但是使用I/O重定向功能可以改变这一惯例。

### 标准输出重定向

- ​	使用重定向操作符"`>`"后面接文件名，我们就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上。

```shell
ls -l /root > a_01.txt 
//将ls命令的结果(-l为命令参数；/root为执行目录)保存到文件a_01.txt中。
```

- 如果我们指定一个不存在的目录，那么错误信息将会显示在屏幕上，而不是重定向到文件中。

  - 此时，查看输出文件，可以看到输出文件大小为零！！
  - 注意：由于再次执行重定向到时候只是得到了一条错误信息，所以重定向会重新改写这个文件，并在出现错误的情况下停止操作，最终导致文件内容被删除。

- 如果我们<u>**删除一个文件的内容**</u>，我们可以<u>仅仅使用重定向符，前面不加任何命令。</u>

- ```shell
  > a_01.txt
  //这将删除文件的内容，或者创建一个新的空文件。
  ```

- 使用重定向符"`>>`"来从文件尾部添加输出内容，这样子不会从头覆盖文件。

### 标准错误重定向

​	要实现标准错误的重定向，需要了解`文件描述符`。

- 一个程序可以把生成的输出内容发送到任意文件流中。如果把这些文件流的前三个分别对应标准输入文件、标准输出文件、标准错误文件，那么shell将在内部用文件描述符来索引它们为0、1、2。

  - 因此，重定向标准错误使用`2>`

  - ```shell
    ls -l /helloworld 2> a_01.txt
    ```

### 将标准错误和标准输出重定向到同一个文件中

​	希望把程序的所有输出内容都放在同一个独立的文件中。为此，我们必须同时重定向标准输出和标准错误。

- 传统方法（旧版本shell中）

  - ```shell
    ls -l /root > a_01.txt 2>&1
    //注意最后的 2>&1
    //这将执行两个重定向操作。
    ```

  - 首先，标准输出重定向到文件中。

  - 然后，`2>&1`把文件描述符2（标准错误）重定向到文件描述符1（标准输出）中。

- 最新的bash版本提供了更高效的方法，实现联合重定向操作。

- ```shell
  ls - /root &> a_01.txt
  //使用&>
  ```

  - 只使用一个`&>`就把标准输出和标准错误都重定向到了文件中。

### 处理不想要的输出

​	如果我们不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。

- 将输出重定向到一个称为`/dev/null`的特殊文件中来实现。

  - 这个文件是一个被称为位桶的系统设备，接受输入但是不对输入进行任何处理。

  - 隐藏一个命令的错误信息

  - ```shell
    ls -l /helloworld 2> /dev/null
    ```

### 标准输入重定向

#### cat——合并文件

​	cat命令：读取一个或多个文件，并把它们复制到标准输出文件中。格式如下：`cat [file]`

- cat命令可以接受多个文件作为参数。

- 如果有多个文件move.mpeg.001 move.mpeg.002 move.mpeg.003···

  - 使用通配符和重定向让它们合并在一起

  - ```shell
    cat move.mpeg.0* > move.mpeg
    ```

- 如果cat命令没有给出任何的参数，将会等待键盘的输入。

  - ```shell
    cat 
    hello world.//此时按下ctrl+D，告知cat 命令它已经到达了标准输入的文件尾。
    //得到结果：hello world.
    ```

- 在缺少文件名的情况下，cat将标准输入内容复制到标准输出文件中。

- ```scala
  cat > a.txt 
  hello world i need you mac.
  //使用这个命令相当于执行了世界上最愚蠢的文字处理器！！！
  ```

- 将文件作为标准输入`cat < a.txt`，很少用。只是更清楚的说明了文件作为了标准输入的源头。

## 管道

​	使用`|`操作符可以把一个命令的标准输出传送到另一个命令的标准输入中。	

Command1 | command2

### 过滤器

​	常常用来将多个命令合在一起构成一个管道。这种命令通常被称为过滤器。

```shell
ls /bin /usr/bin | sort | less
//将 /bin目录下、/usr/bin目录下可执行程序合并成一个列表，并且按照顺序排列，最后查看列表。
```

### uniq——报告或忽略文中的重复的行

​	uniq：接受来自于标准输入或者一个单一文件名参数对应的<u>排好序的数据列表</u>，**默认情况下，该命令删除重复的行。**

```shell
[root@144 aaa_test]# cat a.txt abc.txt | sort | uniq | less
# uniq命令删除sort命令输出内容中的任意重复行。
[root@144 aaa_test]# cat a.txt abc.txt | sort | uniq -d| less
#在uniq 命令之后加上 -d参数，则返回重复行。
```

### wc——显示行数、字数、字节数

- -l选项，限制只显示行数。

- ```shell
  #查看已经排好序的列表的条目数
  ls /bin /usr/bin |sort|uniq| wc -l
  ```

### grep——打印匹配行

​	grep：用来在文件中查找匹配的文本。使用格式`grep pattern [file...]`

-  列出程序中搜索的文件名中包含zip的所有文件。

- ```shell
  ls /bin /usr/bin | sort | uniq | grep zip
  ```

### head/tail——打印文件开头/结尾部分

head：输出文件开头10行内容。

tail：输出文件结尾最后10行的内容。

- 我们可以使用`-n`选项来调整输出的行书。
- tail有一个`-f`选项，用来实时查看文件，将会持续监控这个文件，一旦添加了新行，新行将会立即显示在屏幕上。该监视将会在ctrl+C之后停止。

### tee——从stdin读取数据，并同输出到stdout和文件

```shell
ls -l ./ | grep .log | tee aaa_test/a.txt 
#将 ls命令的输出（用grep过滤）输出到控制台+a.txt文件中
```



